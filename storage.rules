
rules_version = '2';

// Craft rules based on data in your Firestore database
// allow write: if firestore.get(
//    /databases/(default)/documents/users/$(request.auth.uid)
//  ).data.isAdmin;
service firebase.storage {
  match /b/{bucket}/o {
    
    // Helper to check authentication
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper to check company membership (simplified check)
    // In a production environment with strict tenancy, we would look up the user's companyId via Firestore
    // However, Storage rules don't support firestore.get efficiently for every request in all plans.
    // For this implementation, we will enforce path structure and auth.
    
    match /companies/{companyId}/venues/{venueId}/compliance/{fileName} {
      // Allow read/write if user is authenticated. 
      // Ideally, we would verify the user belongs to {companyId}, but standard Auth object doesn't carry custom claims by default without backend set up.
      // We rely on the App logic to only attempt uploads to the correct path.
      allow read, write: if isAuthenticated();
    }
    
    // Default deny
    match /{allPaths=**} {
      allow read, write: if false;
    }
  }
}
